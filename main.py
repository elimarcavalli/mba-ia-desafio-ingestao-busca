import os
import sys
import subprocess
import shutil
import time
from pathlib import Path

# Configuration - use absolute paths for reliability
PROJECT_ROOT = Path(__file__).parent.resolve()
VENV_DIR = PROJECT_ROOT / "venv"
REQUIREMENTS_FILE = PROJECT_ROOT / "requirements.txt"
DOCKER_COMPOSE_FILE = PROJECT_ROOT / "docker-compose.yml"
APP_PATH = PROJECT_ROOT / "src/presentation/web/chainlit_app.py"
ENV_FILE = PROJECT_ROOT / ".env"
CHAINLIT_PORT = 8000

COLORS = {
    "HEADER": "\033[95m",
    "BLUE": "\033[94m",
    "GREEN": "\033[92m",
    "WARNING": "\033[93m",
    "FAIL": "\033[91m",
    "ENDC": "\033[0m",
}

def print_color(text, color):
    print(f"{COLORS.get(color, '')}{text}{COLORS['ENDC']}")

def run_command(command, check=True, capture_output=False):
    """Run a shell command."""
    try:
        result = subprocess.run(
            command,
            check=check,
            shell=True,
            text=True,
            capture_output=capture_output
        )
        return result
    except subprocess.CalledProcessError as e:
        print_color(f"Error executing command: {command}", "FAIL")
        if e.stdout: print(f"Stdout: {e.stdout}")
        if e.stderr: print(f"Stderr: {e.stderr}")
        # Don't exit immediately on all errors, let caller handle
        raise e

def get_venv_python():
    """Get the path to the python executable in the venv."""
    if sys.platform == "win32":
        return VENV_DIR / "Scripts" / "python.exe"
    return VENV_DIR / "bin" / "python"

def get_venv_pip():
    """Get the path to the pip executable in the venv."""
    if sys.platform == "win32":
        return VENV_DIR / "Scripts" / "pip.exe"
    return VENV_DIR / "bin" / "pip"

# --- Configuration Wizard ---

def configure_env():
    """Interactively creates the .env file."""
    print_color("\n[Configuration Wizard]", "HEADER")
    print("Let's set up your environment variables.")

    if ENV_FILE.exists():
        print_color("An existing .env file was found.", "WARNING")
        overwrite = input("Do you want to reconfigure and OVERWRITE it? (y/N): ").lower()
        if overwrite != 'y':
            return

    provider = ""
    while provider not in ["1", "2"]:
        print("\nSelect your LLM Provider:")
        print("1. OpenAI")
        print("2. Google Gemini")
        provider = input("Choice (1/2): ").strip()

    llm_provider = "openai" if provider == "1" else "google"
    api_key = ""
    
    if llm_provider == "openai":
        api_key = input("Enter your OPENAI_API_KEY: ").strip()
    else:
        api_key = input("Enter your GOOGLE_API_KEY: ").strip()

    # Database URLs: Chainlit needs postgresql:// (asyncpg), while the app auto-converts to postgresql+psycopg://
    db_base_url = "postgresql://postgres:postgres@localhost:5432/rag"

    env_content = f"""# Generated by main.py
LLM_PROVIDER={llm_provider}

# Database Configuration
# Chainlit uses this directly (asyncpg requires postgresql://)
# The application auto-converts to postgresql+psycopg:// internally
DATABASE_URL={db_base_url}
PG_VECTOR_COLLECTION_NAME=document_chunks
PDF_PATH=document.pdf

# API Keys
OPENAI_API_KEY={api_key if llm_provider == 'openai' else ''}
GOOGLE_API_KEY={api_key if llm_provider == 'google' else ''}

# Models (Defaults)
OPENAI_EMBEDDING_MODEL='text-embedding-3-small'
GOOGLE_EMBEDDING_MODEL='models/embedding-001'
"""
    ENV_FILE.write_text(env_content)
    print_color("\nConfiguration saved to .env!", "GREEN")


# --- Steps ---

def step_reset_system():
    print_color("\n[System Reset]", "FAIL")
    confirm = input("This will DELETE your venv, DROP Docker containers/volumes, and RESET configuration. Are you sure? (type 'yes' to confirm): ")
    if confirm != "yes":
        print("Reset cancelled.")
        return

    # 1. Docker Down -v
    print_color("Stopping Docker and removing volumes...", "BLUE")
    try:
        run_command("docker compose down -v", check=False)
    except Exception:
        pass # Ignore if docker wasn't running

    # 2. Remove venv
    if VENV_DIR.exists():
        print_color("Removing virtual environment...", "BLUE")
        shutil.rmtree(VENV_DIR)

    # 3. Remove .env
    if ENV_FILE.exists():
        print_color("Removing configuration (.env)...", "BLUE")
        os.remove(ENV_FILE)
        
    print_color("System reset successfully! Starting fresh setup...", "GREEN")
    time.sleep(1)

def step_check_create_venv():
    print_color("\n[1/4] Checking Virtual Environment...", "HEADER")
    
    pip_path = get_venv_pip()
    python_path = get_venv_python()
    
    # Check if venv exists AND is complete (has pip)
    venv_is_valid = VENV_DIR.exists() and pip_path.exists() and python_path.exists()
    
    if venv_is_valid:
        print_color("Virtual environment OK.", "GREEN")
        return
    
    # Venv doesn't exist or is corrupted
    if VENV_DIR.exists():
        print_color("Virtual environment is corrupted or incomplete. Recreating...", "WARNING")
        shutil.rmtree(VENV_DIR)
    
    print_color("Creating virtual environment...", "BLUE")
    
    # Determine which python to use for creating the venv
    # If the user ran "python main.py" from the venv, and then did a Reset,
    # sys.executable still points to the DELETED venv python!
    creator_python = sys.executable
    
    # Check if current executable is valid
    if not os.path.exists(creator_python):
        print_color("Current python interpreter not found. Falling back to system 'python3'...", "WARNING")
        creator_python = shutil.which("python3") or shutil.which("python")
        
    if not creator_python:
        print_color("Could not find a valid python interpreter to create venv!", "FAIL")
        sys.exit(1)
        
    subprocess.run([creator_python, "-m", "venv", str(VENV_DIR)], check=True)
    print_color("Virtual environment created successfully!", "GREEN")

def step_install_requirements():
    print_color("\n[2/4] Installing/Updating Components...", "HEADER")
    pip_cmd = get_venv_pip()
    
    if not REQUIREMENTS_FILE.exists():
        print_color("requirements.txt not found!", "FAIL")
        sys.exit(1)

    print_color("Installing requirements...", "BLUE")
    # Upgrade pip first, silence output a bit
    run_command(f'"{pip_cmd}" install --upgrade pip', check=False, capture_output=True)
    run_command(f'"{pip_cmd}" install -r "{REQUIREMENTS_FILE}"')
    print_color("Dependencies checked.", "GREEN")

def step_docker_compose():
    print_color("\n[3/4] Starting Infrastructure (Docker)...", "HEADER")
    if not DOCKER_COMPOSE_FILE.exists():
        print_color("docker-compose.yml not found!", "FAIL")
        sys.exit(1)

    # Check config validity
    if not ENV_FILE.exists():
        print_color(".env file missing! Starting configuration wizard...", "WARNING")
        configure_env()

    print_color("Ensuring infrastructure is up...", "BLUE")
    run_command("docker compose up -d")
    
    # Wait a moment for DB to be ready
    print_color("Waiting for database to be ready...", "BLUE")
    time.sleep(3)
    
    # Initialize Chainlit tables (required for data layer)
    print_color("Initializing Chainlit database tables...", "BLUE")
    python_cmd = get_venv_python()
    try:
        run_command(f'"{python_cmd}" -c "import sys; sys.path.insert(0, \'.\'); exec(open(\'src/scripts/init_chainlit_db.py\').read())"', check=True)
    except Exception as e:
        print_color(f"Warning: Could not initialize Chainlit tables: {e}", "WARNING")
    
    # Apply migrations to fix any constraint issues
    print_color("Ensuring schema compatibility...", "BLUE")
    try:
        run_command(f'"{python_cmd}" -c "import sys; sys.path.insert(0, \'.\'); exec(open(\'src/scripts/migrate_chainlit_schema.py\').read())"', check=True, capture_output=True)
    except Exception:
        pass  # Silent - migrations are idempotent
    
    print_color("Infrastructure ready!", "GREEN")

def step_run_app():
    print_color("\n[4/4] Launching Application...", "HEADER")
    
    if not APP_PATH.exists():
        print_color(f"Application file {APP_PATH} not found!", "FAIL")
        sys.exit(1)

    print_color(f"Starting Chainlit server on port {CHAINLIT_PORT}...", "GREEN")
    print_color("Press Ctrl+C to stop the server.", "WARNING")
    print_color("Please wait 30 seconds and visit http://localhost:8000", "GREEN")
    
    try:
        python_cmd = get_venv_python()
        # Run Chainlit from the web directory so it can find the public folder
        web_dir = APP_PATH.parent
        cmd = [str(python_cmd), "-m", "chainlit", "run", "chainlit_app.py", "-w", "--port", str(CHAINLIT_PORT)]
        subprocess.run(cmd, check=True, cwd=str(web_dir))
    except KeyboardInterrupt:
        print_color("\nServer stopped by user.", "WARNING")
    except subprocess.CalledProcessError as e:
        print_color(f"\nServer exited with error code {e.returncode}.", "FAIL")


def step_kill_existing():
    """Kills any existing Chainlit processes or anything on port 8000."""
    print_color("\n[Force Restart] check for existing processes...", "HEADER")
    
    # 1. Kill by Port 8000 (Mac/Linux specific, but user is on Mac)
    try:
        # Find PID on port 8000
        cmd = "lsof -ti:8000"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        pids = result.stdout.strip().split()
        
        for pid in pids:
            if pid:
                print_color(f"Killing process on port 8000 (PID: {pid})...", "WARNING")
                subprocess.run(f"kill -9 {pid}", shell=True)
    except Exception:
        pass

    # 2. Kill by name 'chainlit'
    try:
        print_color("Ensuring no stray chainlit processes remain...", "BLUE")
        subprocess.run("pkill -f chainlit", shell=True, stderr=subprocess.DEVNULL)
    except Exception:
        pass
    
    time.sleep(1)
    print_color("Cleaned up existing processes.", "GREEN")

def main_menu():
    print_color("\n=== MBA Software Engineering with AI - Project Manager ===", "HEADER")
    print("1. Start System (Normal)")
    print("2. Force Restart (Kill existing + Start)")
    print("3. Quick Launch (Skip checks)")
    print("4. Stop All Processes (Kill Only)")
    print("5. Reset System (Wipe User Data & Config Only)")
    print("6. Exit")
    
    choice = input("\nSelect option (1-6): ").strip()
    return choice

def main():
    try:
        while True:
            choice = main_menu()
            
            if choice == "6":
                print("Exiting...")
                sys.exit(0)
                
            elif choice == "4":
                step_kill_existing()
                # Loop back to menu after stopping
                continue
                
            elif choice == "5":
                step_reset_system()
                # Loop back to menu after reset
                continue
            
            elif choice == "3":
                # Quick Launch - only run the app
                step_run_app()
                break
            
            elif choice == "2":
                step_kill_existing()
                # Proceed to full start
                
            elif choice == "1":
                # Proceed to full start
                pass
            
            else:
                print_color("Invalid option. Please try again.", "WARNING")
                continue

            # --- Start Flow (Choices 1 & 2) ---
            
            # Step 0: Check configuration FIRST (before any heavy setup)
            if not ENV_FILE.exists():
                print_color("\n[0/4] Initial Configuration Required", "HEADER")
                configure_env()
            
            # Step 1-4: Normal setup
            step_check_create_venv()
            step_install_requirements()
            step_docker_compose()
            step_run_app()
            # Break loop after starting app (since app captures shell until Ctrl+C)
            break
        
    except KeyboardInterrupt:
        print_color("\nSetup aborted by user.", "FAIL")
    except Exception as e:
        print_color(f"\nAn unexpected error occurred: {e}", "FAIL")
        # Print traceback for debugging
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
